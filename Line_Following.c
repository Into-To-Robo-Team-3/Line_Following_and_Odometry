#pragma config(Sensor, S1,     light,          sensorLightActive)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, encoder)

#define BLACK 40
#define POWER 50

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/**********************************************
 * Lab 3 : Starter code
 * Written by Kaushik Viswanathan,
 * Modified by Allan Wang (Jan 2017)
 * Feel free to modify any part of these codes.
 **********************************************/

//Global variables - you will need to change some of these
//Robot's positions
float robot_X = 0.0, robot_Y = 0.0, robot_TH = 0.0;

int velocityUpdateInterval = 5;
int PIDUpdateInterval = 2;

//Change these during demo
int inputStraight[2] = {120, 0}; // in in
int inputTurn[2] = {0, 0}; // in degrees, negative means clockwise rotation
int motorPower = 50;

/*****************************************
 * Complete this function so that it
 * continuously updates the robot's position
 *****************************************/
void turn(int degrees){

}

task dead_reckoning()
{

	while(1)
	{
	/*	int fact=5*120;
		int dist=fact/138;  //distance to travel
    int od=2.25;     //Wheel diameter
    int cir=od*PI; //Wheel circumference
    int ticks=360/cir;  //ticks per inch
    while(nMotorEncoder(leftMotor)<dist*ticks){
   		motor[leftMotor]=POWER;
   		motor[rightMotor]=POWER;
    }
    motor[leftMotor]=0;
    motor[rightMotor]=0;
*/
		/*Code that plots the robot's current position and also prints it out as text*/
		nxtSetPixel(50 + (int)(100.0 * robot_X), 32 + (int)(100.0 * robot_Y));
		//nxtDisplayTextLine(0, "X: %f", robot_X);
		//nxtDisplayTextLine(1, "Y: %f", robot_Y);
		//nxtDisplayTextLine(2, "t: %f", robot_TH);

		wait1Msec(velocityUpdateInterval);
	}
}

/*****************************************
 * Function that draws a grid on the LCD
 * for easier readout of whatever is plot
 *****************************************/
void draw_grid()
{
	for(int i = 0; i < 65; i++)
	{
		nxtSetPixel(50, i);
		int grid5 = (i - 32) % 5;
		int grid10 = (i - 32) % 10;
		if(!grid5 && grid10)
		{
			for(int j = -2; j < 3; j++)
			{
				nxtSetPixel(50 + j, i);
			}
		}
		else if(!grid10)
		{
			for(int j = -4; j < 5; j++)
			{
				nxtSetPixel(50 + j, i);
			}
		}
	}
	for(int i = 0; i < 101; i++)
	{
		nxtSetPixel(i, 32);
		int grid5 = (i - 100) % 5;
		int grid10 = (i - 100) % 10;
		if(!grid5 && grid10)
		{
			for(int j = -2; j < 3; j++)
			{
				nxtSetPixel(i, 32 + j);
			}
		}
		else if(!grid10)
		{
			for(int j = -4; j < 5; j++)
			{
				nxtSetPixel(i, 32 + j);
			}
		}
	}
}

/**********************************************
 * Function that judges if two floats are equal
 **********************************************/
 bool equal(float a, float b) {
   float epsilon = 1;
   if (abs(a-b) < epsilon) {
     return true;
   } else {
     return false;
   }
 }

task followLine(){
	int dir = 1; //1 is left, 0 is right
	while(true){ //repeats indefinitely
		while(SensorValue(light) < BLACK){ //while on the line
			if(dir){ //if direction is set to left
				motor[leftMotor] = POWER/2; //
				motor[rightMotor] = POWER/4;// move left
			}
			else{
				motor[leftMotor] = POWER/4; //otherwise move right
				motor[rightMotor] = POWER/2;
			}
		 nxtDisplayTextLine(0, "X: %d", SensorValue(light));
		}
		//when it leaves the line
		int arc = 20; //robot sweeps in bigger and bigger arcs back and forth until it finds the line
									//(measured in miliseconds
		if(dir) dir = 0; //toggles dir
		else dir = 1;

		while(true){
			if(dir){
				motor[leftMotor] = POWER/4;
				motor[rightMotor] = POWER/2;
				for(int t = 0; t<arc; t++){//for the length of arc
					wait1Msec(1);
					if(SensorValue(light) > BLACK) //wait a milisecond then check if it's found the line
						break;
				}
				dir = 0; //toggles dir
			}
			else{ //same but for opposite direction
				motor[leftMotor] = POWER/2;
				motor[rightMotor] = POWER/4;
				for(int t = 0; t<arc; t++){
					wait1Msec(1);
					if(SensorValue(light) > BLACK)
						break;
				}
				dir = 1;
			}
			arc *=2; //enlarges arc
		}
	}
}
/*****************************************
 * Main function - Needs changing
 *****************************************/
task main()
{
	/* Reset encoders and turn on PID control */
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	nMotorPIDSpeedCtrl[leftMotor] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[rightMotor] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;

	int goalStraight = 0;
	int goalTurn = 0;
	float start_X = 0;
	float start_Y = 0;
	float distTravelled = 0;

	draw_grid();
	//startTask(followLine);
	//while(true){}
	startTask(dead_reckoning);

	for(int i = 0; i < 2; i++)
	{
		goalStraight = inputStraight[i];
		goalTurn = inputTurn[i];
		//Turn
		float od=2.25;     //Wheel diameter
		float turnAng=(float)goalTurn; //angle to turn CHANGE ME
		float dwb=6.54; //wheel base diameter
		float wheelAng=((dwb*turnAng*720)/(od*824));//(1+exp(-1*turnAng/30+1)); //Angle we want the wheel to turn
		while(nMotorEncoder(leftMotor) < (int)wheelAng||(wheelAng<0&&nMotorEncoder(leftMotor)>(int)wheelAng)){
			nxtDisplayTextLine(0, "Ticks: %f", wheelAng);
			nxtDisplayTextLine(1, "TurnAng: %f", ((float)nMotorEncoder(leftMotor)*od)/dwb);
			if(wheelAng>0){
   			motor[leftMotor]=20;
   			motor[rightMotor]=-20;
   		}
   		else{
   			motor[leftMotor]=-20;
   			motor[rightMotor]=20;
   		}
	  }	
	  motor[rightMotor] = 0;
	  motor[leftMotor] = 0;
	  nMotorEncoder[leftMotor] = 0;
		nMotorEncoder[rightMotor] = 0;
		
		wait1Msec(100 * 5);
		//
		//Go Straight
		float fact=goalStraight*120;
		float dist=fact/138;  //distance to travel
 
    float cir=od*PI; //Wheel goalStraightumference
    float ticksperin=360/cir;  //ticks per inch
    float ticks=dist*ticksperin; //total ticks 
    while(nMotorEncoder(leftMotor)<(int)ticks){
   		motor[leftMotor]=POWER;
   		motor[rightMotor]=POWER;
   	}
   	motor[leftMotor]=0;
    motor[rightMotor]=0;
    nMotorEncoder[leftMotor] = 0;
		nMotorEncoder[rightMotor] = 0;
   	//wait1Msec(1000);
   	

		start_X = robot_X;
		start_Y = robot_Y;

		/* Example codes for moving in a striaght line a certain distance,
		 * you need to change this for MUCH better performance 
		motor[motorA] = motorPower;
		motor[motorB] = motorPower;
		distTravelled = sqrt(pow(robot_X - start_X, 2) + pow(robot_Y - start_Y, 2));
		while (!equal(distTravelled, goalStraight)) {
			distTravelled = sqrt(pow(robot_X - start_X, 2) + pow(robot_Y - start_Y, 2));
		}
*/

		wait1Msec(100 * 5);
	}
	motor[motorA] = 0;
	motor[motorB] = 0;
	nNxtButtonTask  = 0;
	while(nNxtButtonPressed != kExitButton) {}
}
